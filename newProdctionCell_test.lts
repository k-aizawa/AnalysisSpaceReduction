const N=1
set Requests={reqA,reqB}
set MOVE={move[0..N],moveOut,moveFeed}
set Controllable={pickup,putdown,MOVE,process[0..N],reset}//*/}


Arm = (Requests->AtProcess[0]),
AtFeed = (
//	pickup->picksuccess->AtFeed|
//	putdown->putsuccess->AtFeed|
	move[i:0..N]->AtProcess[i]|
//	moveOut->AtOut|
	reset->Arm),
AtProcess[i:0..N]=(
//	pickup->AtProcess[i]|
	putdown->putsuccess->AtProcess[i]|
//	process[i]->AtProcess[i]|
	move[j:0..N]->AtProcess[j]
//	|moveFeed->AtFeed
//	|moveOut->AtOut
),
AtOut=(
//	pickup->picksuccess->AtOut|
//	putdown->putsuccess->AtOut|
	moveFeed->AtFeed|
	move[i:0..N]->AtProcess[i]).

Process(I=0)=(process[I]->Process/*|process[I].fail->Process*/).
//ENV=(a->(b->d->ENV|c->d->ENV|d->ENV)).

Cont=(reqB->pickup->picksuccess->move[1]->putdown->putsuccess->process[1]->process[1].end->pickup->picksuccess->moveOut->putdown->putsuccess->moveFeed->reset->Cont).

//ltl_property NOT_TWICE_B=[](b->X(!b W e))
//ltl_property NOT_TWICE_C=[](c->X(!c W e))


fluent PROCESSING[i:0..N]=<process[i],process[i].end>
fluent PROCESSED[i:0..N]=<process[i].end,reset> 
fluent AT_PROCESS[i:0..N]=<move[i],MOVE\{move[i]}>
fluent PICKED =<picksuccess,putsuccess>
fluent PUTTED =<putsuccess,picksuccess>initially 1
fluent AT_OUT =<moveOut,MOVE\{moveOut}>
fluent AT_FEED =<moveFeed,MOVE\{moveFeed}> initially 1

ltl_property NOMEANMOVE=[]((forall[i:0..N]!(X move[i]&&AT_PROCESS[i]))&&({MOVE}-> X(!{MOVE}W {Controllable}\{MOVE})))
ltl_property NO_ENTER_FEED=[]({Requests}->X((!moveFeed W (AT_OUT&&putsuccess))))
ltl_property NO_PICK_PROCESSING=[]forall[i:0..N](!(PROCESSING[i]&&AT_PROCESS[i]&&picksuccess))
ltl_property TRANSFER=[]((pickup->!PICKED)&&(putdown->!PUTTED))
ltl_property MUST_PROCESS=[]((moveOut->X(AT_OUT W putsuccess))&&(moveFeed->X(AT_FEED W picksuccess))&&(moveFeed->X(!pickup W reset))&&(forall[i:0..N](move[i]->X(AT_PROCESS[i] W process[i]))))

ltl_property HANDLE=[]((putsuccess->X{Controllable}\{pickup}&&!pickup)&&(picksuccess->X{Controllable}\{putdown}&&!putdown)&&(pickup->PUTTED)&&(putdown->PICKED)&&!(AT_FEED&&putdown)&&!(AT_OUT&&pickup)&&forall[i:0..N]((AT_PROCESS[i]&&pickup)->X(!(AT_PROCESS[i]&&pickup)W(AT_PROCESS[i]&&putsuccess)))) 
//ltl_property INITIAL_HANDLE= forall[i:0..N](!(AT_PROCESS[i]&&pickup)W(AT_PROCESS[i]&&putsuccess))

ltl_property PROCESS_RULE=[]forall[i:0..N]((process[i].end->X(!process[i] W (AT_PROCESS[i]&&putsuccess)))&&!(PROCESSING[i]&&AT_PROCESS[i]&&putsuccess)&&(process[i]->X(!process[i] W reset)))
ltl_property INITIAL_RULE=forall[i:0..N]((!process[i] W (AT_PROCESS[i]&&putsuccess))&&(!(AT_PROCESS[i]&&pickup)W(AT_PROCESS[i]&&putsuccess)))

ltl_property PROCESS_B=[](reqB->X((!reset W process[1].end)&&(!process[0].end W reset)&&((((putdown&&AT_OUT)->PROCESSED[1])W reset))))
ltl_property PROCESS_A=[](reqA->X((!reset W process[0].end)&&(!process[1].end W reset)&&((((putdown&&AT_OUT)->PROCESSED[0])W reset))))

||ENV2= (Arm||forall[i:0..N](Process(i))).

controllerSpec CONT = {
safety = {
//	NO_ENTER_FEED,
//	NO_PICK_PROCESSING,
	PROCESS_RULE,
	HANDLE,
//	INITIAL_RULE,
//	PROCESS_A,
//	PROCESS_B,
//	NOMEANMOVE,
//	TRANSFER,
//	MUST_PROCESS//*/
//	A,B
	}
	controllable = {Controllable}
}


controller ||CC = (ENV2)~{CONT}~(Cont).
||CCC=CC.
